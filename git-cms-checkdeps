#!/usr/bin/env python

import sys, re, json, os
from os import environ, popen, path
from os.path import dirname, realpath
from optparse import OptionParser
import subprocess
import re

#Idea: diff checked out packages.
#     looking for changed headers
#     find all packages that depend on those headers
#     print that list.

#if any argument, print help and exit 

poisondir = "poison"
checkout = 0
checkpython = 0
checkheader = 0
checkbuildfile = 0
printFileNames = 0
poison_includes = None
poison_only = 0
jobs = 4
 


help_text = "\n\
    Utility to check your local development area against the CMSSW release.\n\
    Any modified header files or python modules are found and the package \n\
    dependencies of these files will be returned. addpkg-ing these packages\n\
    and rebuilding them should provide a full and consistent build."

parser = OptionParser(usage=help_text)
parser.add_option("-a", dest="checkout", default=1, help = "will add/checkout the packages into your development area")
parser.add_option("-x", dest="checkout", default=1, help = "look for header files and their dependencies (ON by default)")
parser.add_option("-p", dest="checkpython", default=1, help = "look for python modules and their dependencies  (ON by default)")
parser.add_option("-b", dest="checkbuildfile", default=1, help = "look for BuildFile files and their dependencies (OFF by default)")
parser.add_option("-f", dest="printFileNames", default=1, help = "print name of changed file name instead of type of dependency (OFF by default)")
parser.add_option("-d", dest="poison_includes", default=1, help = "do not create dummy copy of deleted files in ${poisondir} directory. Dummy copies\
 are useful to find out if deleted headers files are included by other source files.")
parser.add_option("-D", dest="poison_only", default=1, help = "only dummy copy of deleted files in ${poisondir} directory created.\
 NOTE: all other dependency check/add command-line args are ignored.")
parser.add_option("-j", dest="checkout", default=1, help = "<N> Run N threads to checkout packages. Default is ${jobs}")
parser.add_option("-A", dest="checkout", default=1, help = "will check all dependencies i.e. header (-h), python(-p) and BuildFile(-b)")

(options, args) = parser.parse_args()

# print options.checkout

if poison_only:
  checkpython = 0
  checkheader = 0
  checkbuildfile = 0
  checkout = 0
  poison_includes = 1
elif (not checkpython) & (not checkheader) & (not checkbuildfile):
  checkpython = 1
  checkheader = 1
  
if poison_includes is None: poison_includes = 0

try: localtop = environ["CMSSW_BASE"]
except KeyError: print("ERROR: Could not find developer area base path. Please run \"cmsenv\" in a developer area.")

try: releasetop = environ["CMSSW_RELEASE_BASE"]
except KeyError: print("ERROR: Could not find release base path. Please run this script from a developer area.")

vals = {}

if checkheader:
  depfile = "%s/etc/dependencies/usedby.out.gz" % releasetop
  if path.isfile(depfile): readDependencyInfo(depfile, vals)
  else: 
    print("ERROR: This release appears not to support the functionality of this script (170pre4 and higher). Sorry")
    sys.exit(1)

if checkpython:
  depfile = "%s/etc/dependencies/pyusedby.out.gz" % releasetop
  if path.isfile(depfile): readDependencyInfo(depfile, vals)
  sys.exit(1)

if checkbuildfile:
  depfile = "%s/etc/dependencies/bfusedby.out.gz" % releasetop
  if path.isfile(depfile): readDependencyInfo(depfile, vals)
  sys.exit(1)

os.chdir("%/src" % localtop)

changedFiles = []
deletedFiles = []
reltag = None
if os.environ["CMSSW_GIT_HASH"]:
  reltag = os.environ["CMSSW_GIT_HASH"]
else:
  reltag = os.environ["CMSSW_VERSION"]

upackages = {}

cmd = "git diff -G '^([^\$]+\$|[^\$]*[\$][^\$]*\$|([^\$]*[\$])(\$|[^RAIDLNSH]|(R[^eC]|A[^u]|I[^d]|D[^a]|L[^o]|N[^a]|S[^o]|H[^e])|(Re[^v]|RC[^S]|Au[^t]|Id[^:]|Da[^t]|Lo[^g]|Na[^m]|So[^u]|He[^a])|(Rev[^i]|RCS[^f]|Aut[^h]|Dat[^e]|Log[^:]|Nam[^e]|Sou[^r]|Hea[^d])|(Revi[^s]|RCSf[^i]|Auth[^o]|Date[^:]|Name[^:]|Sour[^c]|Head[^e])|(Revis[^i]|RCSfi[^l]|Autho[^r]|Sourc[^e]|Heade[^r])|(Revisi[^o]|RCSfil[^e]|Author[^:]|Source[^:]|Header[^:])|(Revisio[^n]|RCSfile[^:])|(Revision[^:])))' --name-status -r %s | grep -v .gitignore | sed -e 's/[ \t]\+/ /'; git diff --diff-filter R --name-status -r %s" % reltag

process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
while True:
  diff = process.stdout.readline()
  match = re.search(r'^[MUDR]([0-9]*)\s+([^\/]+\/[^\/]+)\/[^\s]+(\s+[^\/]+\/[^\/]+\/[^\s]+|)$', diff)
  if match :
    pack = match.group(2)
    if "pack" not in upackages: 
      upackages["pack"] = []
      if not pack: print(">> Package removed $pack")
    upackages[pack].append(diff)
  if not diff:
   break

packages = sorted(upackages)

for package in packages:
  if re.search(r'^UserCode.*', package): continue
  print ">> Checking %s %s" % (package, reltag)"
  msgs = {"-" : {}, "x": {}}
  for diff in upackages[package]:
    _del = 0
    match  = re.search(r'^(R[0-9]*)(\s+[^\s]+)\s+', diff)
    if match:
      diff = "D %s" % match.group(2)
      if (re.search(r'^(M)', diff) or re.search(r'^(U)', diff) or re.search(r'^(D)', diff)):
        if match.group(1) == "D": _del = 1
        sp2 = diff.split(' ')
        diff = sp2[1]
      else: diff = ""
      if diff: msgs["x"][diff] = 1
      if _del = msgs["-"][diff] = 1
  files = sorted(msgs["-"])
  deletedFiles.append(files)
  changedFiles.append(files)
  for diff in files:
    print("   - $diff")
    del msgs["x"][diff]
  files = sorted(msgs["x"])
  changedFiles.append(files)
  for diff in files:
    print("   x $diff")


recompileList = {}
big_bf = ""
for file in changedFiles:
  if re.search(r'^BigProducts\/[^\/]+\/BuildFile\.xml$', file):
    big_bf = "%s %s" % (big_bf, file)
  if file not in vals: continue
  for dep in vals[file]:
    sp = dep.split("/")
    recompile = "%s/%s" % (sp[0], sp[1])
    if not filter(lambda x:recompile in x, packages):
      scope="header"
      if re.search(r'\.py$', file): scope = "python"
      elif re.search(r'\/BuildFile(\.xml|)$', file): scope = "buildfile"
      recompileList[recompile][scope] = file


if big_bf != "":
  cmd = "git diff -r %s -- %s | sed -e 's/[ \t]\+/ /' | grep '^+' | grep -i '< *use  *name *='" % (reltag, big_bf)
  process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
  while True:
    diff = process.stdout.readline()
    diff = re.sub(r'^[+]', r'', diff)
    for p in diff.split(">"):
      match = re.search(r'^\s*<\s*use\s+name\s*=\s*["]([^"]+)["]\s*', p)
      if match:
        if os.path.exists("%s/src/%s" % (releasetop, match.group(1))):
          recompileList[match.group(1)][biglib] = "BigProducts"
            

t = sorted(recompileList.keys())
len = len(t)
if checkout == 0: print("Packages to check out and compile: %s" % len)
else: print("Checking out these packages: %s" %len)


exitcode = 0
if len > 0:
  for pk in t:
    if printFileNames == 1:
      print "pk %s" % ", ".join(sorted(recompileList.values()))
    else:
      print "pk %s" % ", ".join(sorted(recompileList.keys()))

if checkout == 1:
  os.chdir(localtop)
  #################################
  fh, fname = tempfile(localtop .'/tmp/checkdepsXXXXX')
  for pk in t: print pk
  ###################################
  cmd = "cd %s/src; git cms-addpkg -f %s -q" % (localtop, fname)
  process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
  stdout, stderr = process.communicate()
  exitcode += process.returncode


if exitcode > 0: exitcode = 1
sys.exit(exitcode)

def readDependencyInfo(file, cache):
  try: 
    with open (f, "w") as file: file.write("#error THIS FILE HAS BEEN REMOVED FROM THE PACKAGE.\n")
  except Exception as e: print(e)
  print(file)

def poisonIncludes(deletedFiles, topdir):
  poison = "%s/%s" % (topdir, poisondir)
  if os.path.isdir(poison): os.removedirs(poison)
  poisondata = "%s/.data" % poison
  os.path.makedirs(poisondata)
  if len(deletedFiles) > 0: print(">> Creating dummy files under $poison directory.")
  for file in deletedFiles:
    f = "%s/%s" % (poison,file)
    dir = os.path.dirname(f)
    if not os.path.isdir(dir): os.path.makedirs(dir)
    if re.search(r'\/data\/', file): symlink(poisondata, f)
    else:
      try:
        with open (f, "w") as file: file.write("#error THIS FILE HAS BEEN REMOVED FROM THE PACKAGE.\n")
      except Exception as e: print(e)
    print(file)


if poison_includes: poison_includes(deletedFiles, localtop)
if poison_only: sys.exit(0)
